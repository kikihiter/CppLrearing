https://blog.csdn.net/snowpang/article/details/78934903

C/C++联合体详解
2017年12月29日 20:55:04
阅读数：375
代码如下：

typedef union
{
    unsigned int u;
    struct
    {
        unsigned char a :1;
        unsigned char b :1;
        unsigned char c :6;
        unsigned char d :1;        
    } ST;
}UN;

int main()  
{
    UN un;
    un.u = 0;  
    un.ST.a = 1;   
    un.ST.b = 2;  
    un.ST.c = 3;  
    un.ST.d = 4;  
    printf("%d\n", un.u);  
    return 0;  
} 

运行结果是13

1）注意联合体的定义，就是组成联合体的变量共用一个空间。这个 例子中变量u和ST共用一个空间 
2）现在用的pc机大多为小段结构，我的结果13也是在小段机测试的，如果架构改变，结果可能不同 
3）基于小段结构，数据的低字节保存在内存的低地址中，ST占用9位（Bit），与变量u（32Bit）共用低位的9位 
4）根据小段结构，变量a的地址应该最低，往后依次是b,c,d 
5）un.u = 0; 执行这一步，变量所对应的空间二进制全部为0，即00000000 00000000 00000000 00000000 
6）un.ST.a = 1;执行这一步，变量最后一位变化，即00000000 00000000 00000000 00000001 
7）un.ST.b = 2;执行这一步，由于1位空间无法存储2，所以赋值被截断，原值不变 
8）un.ST.c = 3;执行这一步，变量第3-8位发生变化，变量值变为00000000 00000000 00000000 00001101 
9）un.ST.d = 4;执行这一步，由于1位空间无法存储4，所以赋值被截断，原值不变 
10）所以最终的结果就是00000000 00000000 00000000 00001101 
11）printf(“%d\n”, un.u); 输出结果就是13

unsigned char a :1;这种定义方式，是按位进行定义的，即a只占用一个位，同样b和d都只占用一位，所以如果这三个变量你赋值大于1的话，则自动被截断为1位，即除了低1位有效之外，其它高位的全部被丢弃。按位定义的，和这个变量的类型相关性不是很大，所以不是说a被定义成char就是8位。
